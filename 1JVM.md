
# 补充


## 如何让堆，栈溢出


## 如何排查OOM


# JVM


## JVM 作用

## 什么是JVM内存结构？

![](http://blog-img.coolsen.cn/img/image-20210220111553294.png)

jvm将虚拟机分为5大区域，程序计数器、虚拟机栈、本地方法栈、java堆、方法区；

* 程序计数器：线程私有的，是一块很小的内存空间，作为当前线程的行号指示器，用于记录当前虚拟机正在执行的线程指令地址；
* 虚拟机栈：线程私有的，每个方法执行的时候都会创建一个栈帧，用于存储**局部变量表**、**操作数**、**动态链接**和**方法返回值**等信息，当线程请求的栈深度超过了虚拟机允许的最大深度时，就会抛出StackOverFlowError；
* 本地方法栈：线程私有的，保存的是native方法的信息，当一个jvm创建的线程调用native方法后，jvm不会在虚拟机栈中为该线程创建栈帧，而是简单的动态链接并直接调用该方法；

* 堆：java堆是所有线程共享的一块内存，几乎所有对象的实例和数组都要在堆上分配内存，因此该区域经常发生垃圾回收的操作；
* 方法区：存放**已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据**，即永久代。在JDK1.8之前，方法区和堆逻辑上分离，但物理上使用的是相连的内存。
  * 但在jdk1.8中，用**本地内存中的元空间**替代了**永久代**，不再是与堆相连的连续物理内存。
    * 原永久代中的方法区被分成两部分；1：已加载的类信息，2：运行时常量池；
    * ==加载的类信息被保存在**元空间中**，**运行时常量池保存在堆中**；==
       > 本地内存（Native memory），也称为C-Heap，是供JVM自身进程使用的。当Java Heap空间不足时会触发GC，但Native memory空间不够却不会触发GC。


## 为何使用元空间替换永久代？

1. 永久代的容量需要通过JVM参数进行设置，如果设置不当，会导致经常进行Full GC，甚至OOM；当使用元空间时，可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制。
2. 使用Full GC时，也会扫描永久代，但对永久代的高频扫描意义不大


## 什么是JVM内存模型？

**Java 内存模型**（下文简称 **JMM**）就是在底层处理器内存模型的基础上，定义自己的多线程语义。它明确指定了一组排序规则，来保证线程间的可见性。

这一组规则被称为 **Happens-Before**, JMM 规定，要想保证 B 操作能够看到 A 操作的结果（无论它们是否在同一个线程），那么 A 和 B 之间必须满足 **Happens-Before 关系**：

- **单线程规则**：一个线程中的每个动作都 happens-before 该线程中后续的每个动作
- **监听器锁定规则**：锁的**解锁**动作 happens-before 后续对同一锁的**锁定**动作
- **volatile 变量规则**：对 volatile 字段的写入动作 happens-before 后续对这个字段的每个读取动作
- **线程 start 规则**：线程 **start()** 方法的执行 happens-before 一个启动线程内的任意动作
- **线程 join 规则**：一个线程内的所有动作 happens-before 任意其他线程在该线程 **join()** 成功返回之前
- **传递性**：如果 A happens-before B, 且 B happens-before C, 那么 A happens-before C

怎么理解 happens-before 呢？如果按字面意思，比如第二个规则，线程（不管是不是同一个）的解锁动作发生在锁定之前？这明显不对。happens-before 也是为了保证可见性，比如那个解锁和加锁的动作，可以这样理解，线程1释放锁退出同步块，线程2加锁进入同步块，那么线程2就能看见线程1对共享对象修改的结果。

![](http://blog-img.coolsen.cn/img/image-20210329222941923.png)

Java 提供了几种语言结构，包括 *volatile*, *final* 和 *synchronized*, 它们旨在帮助程序员向**编译器**描述程序的并发要求，其中：

- **volatile** - 保证**可见性**和**有序性**
- **synchronized** - 保证**可见性**和**有序性**; 通过**Monitor**保证一组动作的 **原子性**
- **final** - 通过禁止**在构造函数初始化**和**给 final 字段赋值**这两个动作的重排序，保证**可见性**（如果 **this 引用逃逸**就不好说可见性了）

编译器在遇到这些关键字时，会插入相应的内存屏障，保证语义的正确性。

有一点需要**注意**的是，**synchronized** **不保证**同步块内的代码禁止重排序，因为它通过锁保证同一时刻只有**一个线程**访问同步块（或临界区），也就是说同步块的代码只需满足 **as-if-serial** 语义 - 只要单线程的执行结果不改变，可以进行重排序。

所以说，Java 内存模型描述的是多线程对共享内存修改后彼此之间的可见性，另外，还确保正确同步的 Java 代码可以在不同体系结构的处理器上正确运行。

## Java内存结构中，堆 和 栈 有什么区别？

- 申请方式

  - 栈:**由系统自动分配**。例如，声明在函数中一个局部变量 int b; 系统自动在栈中为 b 开辟空间

  - 堆:需要程序员自己申请，并指明大小，在 c 中 malloc 函数，对于Java 需要手动 new Object()的形式开辟

- 申请后系统的响应

  - 栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。

  - 堆：当系统收到程序的申请时，会遍历记录空闲内存地址的链表，寻找**第一个空间大于所申请空间的堆结点**，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。
    另外，由于找到的堆结点的大小不一定正好等于申请的大小，**系统会自动的将多余的那部分重新放入空闲链表中**。

- 申请大小的限制

  - 栈：栈是向**低地址**扩展的数据结构，是一块**连续**的内存的区域。
    - 即**栈顶的地址和栈的最大容量是系统预先规定好的**，如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。

  - 堆：堆是向**高地址**扩展的数据结构，是**不连续**的内存区域。这是由于系统是用==链表==来存储的空闲内存地址的， 自然是不连续的，而链表的遍历方向是**由低地址向高地址**。
    - 堆的大小受限于计算机系统中有效的虚拟内存。由此可见， 堆获得的空间比较灵活，也比较大。

- 申请效率的比较

  - 栈：由系统自动分配，速度较快。但程序员是无法控制的。

  - 堆：由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。

- heap和stack中的存储内容

  - 栈：在函数调用时，第一个进栈的是主函数中后的下一条指令的地址（函数调用语句的下一条可执行语句），然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。
  当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。

  - 堆：一般是在堆的头部用一个字存放堆的大小。堆中的具体内容有程序员安排。

## 什么情况下会发生栈内存溢出？

> 栈是线程私有的，栈的生命周期和线程一样，每个方法在执行的时候就会创建一个栈帧，它包含局部变量表、操作数栈、动态链接、方法出口等信息，局部变量表又包括基本数据类型和对象的引用；


当**线程请求的栈深度超过了虚拟机允许的最大深度时**，会抛出StackOverFlowError异常，方法递归调用可能会出现该问题；
此时，可以尝试调整参数-xss去调整jvm栈的大小

## 谈谈对 OOM 的认识？如何排查 OOM 的问题？

除了**程序计数器**，其他内存区域都有 OOM 的风险。

- 虚拟机栈
  - 一般经常会发生 `StackOverflowError`，比如**单进程限制 2G 内存**，无限创建线程就会发生栈的 OOM
- 堆内存溢出
  - 这种比较好理解，GC 之后无法在堆中申请内存创建对象就会报错；
  - Java 8 常量池移到堆中，溢出会出 `java.lang.OutOfMemoryError: Java heap space`，设置最大元空间大小参数无效；
- 方法区 OOM
  - 经常会遇到的是**动态生成大量的类、jsp**等；
- 直接内存 OOM
  - 涉及到 -XX:MaxDirectMemorySize 参数和 Unsafe 对象对内存的申请。

排查 OOM 的方法：

- 增加两个参数 `-XX:+HeapDumpOnOutOfMemoryError` `-XX:HeapDumpPath=/tmp/heapdump.hprof`，当 OOM 发生时自动 dump 堆内存信息到指定目录；
- 同时 `jstat` 查看监控 JVM 的内存和 GC 情况，先观察问题大概出在什么区域；
- 使用 MAT 工具载入到 dump 文件，分析大对象的占用情况，比如 HashMap 做缓存未清理，时间长了就会内存溢出，可以把改为弱引用 。

## 谈谈 JVM 中的常量池？

JVM常量池主要分为**Class文件常量池、运行时常量池，全局字符串常量池，以及基本类型包装类对象常量池**。

* **Class文件常量池(静态常量池)**。
  * class文件是一组以字节为单位的二进制数据流，在java代码的编译期间，我们编写的java文件就被编译为.class文件格式的二进制数据存放在磁盘中，其中就包括class文件常量池。


* **运行时常量池**
  * 运行时常量池就是编译后的Class信息在**方法区**中的位置，因此在`本地内存的元空间`中
  * 相对于class常量池一大特征就是具有动态性，java规范并不要求常量只能在运行时才产生，也就是说**运行时常量池的内容并不全部来自class常量池，在运行时可以通过代码生成常量并将其放入运行时常量池中**，这种特性被用的最多的就是`String.intern()`。


* **全局字符串常量池**
  * 字符串常量池是JVM所维护的一个**字符串实例的引用表**，底层C++实现就是一个Hashtable。这些被维护的引用所指的字符串实例，被称作”被驻留的字符串”或”interned string”或通常所说的**进入了字符串常量池的字符串**。 
    * 在JDK1.7之前，字符串常量池位于方法区（永久代）
    * 在JDK1.7，==字符串常量池 和 静态变量 被转移至堆中，而运行时常量池还在方法区==
    * 在JDK1.8，移除了永久代，并用元空间取而代之，==字符串常量池还在堆，运行时常量池还在方法区==
  > 在jdk6中，常量池的位置在**永久代（方法区）**中，==此时常量池中存储的是对象==。
  在jdk7中，常量池的位置在**堆**中，此时，==常量池存储的就是引用==了。

* 基本类型包装类对象常量池
  * java中基本类型的包装类的大部分都实现了常量池技术，这些类是Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现。
  > 另外上面这5种整型的包装类也只是在对应值小于等于`127`时才可使用对象池，也即对象不负责创建和管理大于`127`的这些类的对象。


## Java对象创建过程

当Java虚拟机遇到一条字节码`new`指令时，
1. 首先**检查这个指令的参数是否能在常量池中定位到一个类的符号引用**
2. **检查这个符号引用代表的类是否已被加载、解析和初始化过**。
3. 如果没有，那必须**先执行相应的类加载过程**。
4. 类加载通过后，为新生对象**分配内存**，即**将class文件中的常量池载入到方法区**。
   > 对象所需内存大小在类加载完成后即可确定，分配内存相当于把确定大小的内存块从Java堆中划分出来。

## 对象在堆上分配的两种方式是什么

- 假设Java堆中的内存是绝对规整的，使用过的内存和空闲内存由一个指针作为分界点的指示器，**分配内存就相当于把指针移动等同于对象大小的距离**。这种分配方式称为==指针碰撞==
- 但如果Java堆中的内存不是规整的，就需要虚拟机维护一个列表，**记录可用内存块，在分配时从列表中找到一个足够大的空间来划分给对象实例**。这种方式称为==空闲列表==
> 而Java堆是否规整，由采用的垃圾收集器是否带有空间压缩整理能力决定
> 指针碰撞：Serial、ParNew等带有Compact过程的收集器
> 空闲列表：CMS等基于Mark-Sweep算法的收集器


## 对象的访问定位的两种方式是什么

句柄和直接指针

指针即直接存储对象的地址，而句柄是在句柄中存储对象的地址，通过访问句柄，从而间接地访问对象

## 栈溢出是什么，为什么会栈溢出，为什么一直递归就会栈溢出

栈溢出即StackOverflow，是发生在虚拟机栈上的。当**线程请求的栈深度超过了虚拟机允许的最大深度时**，就会报这个错。
因为栈的空间是有限的，而当我们进行方法调用时，就会将调用这个方法和恢复现场需要的信息插入的栈顶，直到方法运行结束才会将其弹出栈。但一直递归就会导致不停地向栈中插入栈帧，无法弹出。

## 并不是所有的对象都分配到堆上，还可以分配到哪里

还可能被分配到栈上

> 根据逃逸分析的结果，如果确定一个对象**不会逃逸到线程之外**，就可以不在堆上为其分配内存，而是在线程私有的栈上分配

# 垃圾回收

## 如何判断一个对象是否存活？

判断一个对象是否存活，分为两种算法：1：引用计数法；2：可达性分析算法；

**引用计数法**：
给每一个对象设置一个引用计数器，当有一个地方引用该对象的时候，引用计数器就+1，引用失效时，引用计数器就-1；当引用计数器为0的时候，就说明这个对象没有被引用，也就是垃圾对象，等待回收；
缺点：**无法解决循环引用的问题**，当A引用B，B也引用A的时候，此时AB对象的引用都不为0，此时也就无法垃圾回收，所以一般主流虚拟机都不采用这个方法；

**可达性分析法**
从一个被称为GC Roots的对象向下搜索，如果一个对象到GC Roots没有任何引用链相连接时，说明此对象不可用，在java中可以作为GC Roots的对象有以下几种：

* 虚拟机栈中引用的对象
* 方法区类静态属性引用的变量
* 方法区常量池引用的对象
* 本地方法栈JNI引用的对象

> 但一个对象满足上述条件的时候，不会马上被回收，还需要进行两次标记；
> - 第一次标记：判断当前对象是否有finalize()方法并且该方法没有被执行过，若不存在则标记为垃圾对象，等待回收；若有的话，则进行第二次标记；
> - 第二次标记将当前对象放入F-Queue队列，并生成一个finalize线程去执行该方法，虚拟机不保证该方法一定会被执行，这是因为如果线程执行缓慢或进入了死锁，会导致回收系统的崩溃；
> - 如果执行了finalize方法之后仍然没有与GC Roots有直接或者间接的引用，则该对象会被回收；



## 强引用、软引用、弱引用、虚引用是什么，有什么区别？

- 强引用，就是普通的对象引用关系，如 String s = new String("ConstXiong")
- 软引用，用于维护一些可有可无的对象。只有在**内存不足**时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。SoftReference 实现
- 弱引用，弱引用的对象在下一次GC一定会被回收。WeakReference 实现
- 虚引用是一种形同虚设的引用，在现实场景中用的不是很多，它主要用来**跟踪对象被垃圾回收的活动**。PhantomReference 实现

## Java中的垃圾回收算法有哪些？

java中有四种垃圾回收算法，分别是标记清除法、标记整理法、复制算法、分代收集算法；
**标记清除法**：
第一步：利用可达性去遍历内存，把存活对象和垃圾对象进行标记；
第二步：再遍历一遍，将所有标记的对象回收掉；
特点：
  - 效率不行，标记和清除的效率都不高；
  - 标记和清除后会产生大量的不连续的空间分片，可能会导致之后程序运行的时候需分配大对象而找不到连续分片而不得不触发一次GC；


**标记整理法**：
第一步：利用可达性去遍历内存，把存活对象和垃圾对象进行标记；
第二步：将所有的存活的对象向一端移动，将端边界以外的对象都回收掉；
特点：适用于**存活对象多，垃圾少**的情况；需要整理的过程，无空间碎片产生；

![](http://blog-img.coolsen.cn/img/image-20210220111933505.png)

**复制算法**：
将内存按照容量大小分为大小相等的两块，每次只使用一块，当一块使用完了，就将还存活的对象移到另一块上，然后在把使用过的内存空间移除；
特点：不会产生空间碎片；内存使用率极低；


![](http://blog-img.coolsen.cn/img/image-20210220111918592.png)

**分代收集算法**：
根据内存对象的存活周期不同，将内存划分成几块，java虚拟机一般将内存分成新生代和老生代，在新生代中，有大量对象死去和少量对象存活，所以采用复制算法，只需要付出少量存活对象的复制成本就可以完成收集；老年代中因为对象的存活率极高，没有额外的空间对他进行分配担保，所以采用标记清理或者标记整理算法进行回收；

**对比**

![image-20210329224002527](http://blog-img.coolsen.cn/img/image-20210329224002527.png)

## 有哪几种垃圾回收器，各自的优缺点是什么？

垃圾回收器主要分为以下几种：Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1；

* Serial:(标记-复制)
  * 单线程的收集器，收集垃圾时，必须stop the world。
  * 是client级别的默认GC方式。

* ParNew:（标记-复制）
  * Serial收集器的多线程版本，也需要stop the world

* Parallel Scavenge:（标记-复制）
  * 并发的多线程收集器，目标是**达到一个可控的吞吐量**，
  * 和ParNew的最大区别是**GC自动调节策略**：虚拟机会根据系统的运行状态收集性能监控信息，动态设置这些参数，以**提供最优停顿时间和最高的吞吐量**；

* Serial Old:（标记-整理）
  * Serial收集器的老年代版本，单线程收集器。

* Parallel Old：（标记-整理）
  * 是Parallel Scavenge收集器的老年代版本，使用多线程。

* CMS:（标记-清除）
  * 是一种**以获得最短回收停顿时间为目标**的收集器
  * 运作过程：
    * 初始标记（STW）
    * 并发标记
    * 重新标记（STW）
    * 并发清除
  * 收集结束会产生大量空间碎片；

* G1:（标记-整理）
  * 运作流程：
    * 初始标记
    * 并发标记
    * 最终标记
    * 筛选回收（优先回收价值最大的区域）
  * 不会产生空间碎片，可以精确地控制停顿；
  * G1将整个堆分为大小相等的多个Region（区域），G1跟踪每个区域的垃圾大小，在后台维护一个优先级列表，每次根据允许的收集时间，优先回收价值最大的区域，**以达到在有限时间内获取尽可能高的回收效率**；

**垃圾回收器间的配合使用图：**

![](http://blog-img.coolsen.cn/img/image-20210329224424220.png)

**各个垃圾回收器对比**：

![](http://blog-img.coolsen.cn/img/image-20210329230618579.png)

## 详细说一下CMS的回收过程？CMS的问题是什么？

CMS(Concurrent Mark Sweep，并发标记清除) 收集器是以获取最短回收停顿时间为目标的收集器（追求低停顿），它在垃圾收集时使得用户线程和 GC 线程并发执行，因此在垃圾收集过程中用户也不会感到明显的卡顿。

从名字就可以知道，CMS是基于“标记-清除”算法实现的。CMS 回收过程分为以下四步：

1. 初始标记 （STW)
   - 主要是标记 GC Root 开始的下级（注：仅下一级）对象，这个过程会 STW，但是跟 GC Root 直接关联的下级对象不会很多，因此这个过程其实很快。

2. 并发标记 
   - 根据上一步的结果，继续向下标识所有关联的对象，直到这条链上的最尽头。这个过程是多线程的，虽然耗时理论上会比较长，但是其它工作线程并不会阻塞，没有 STW。

3. 重新标记（STW）
   - 顾名思义，就是要再标记一次。为啥还要再标记一次？因为第 2 步并没有阻塞其它工作线程，其它线程在标识过程中，很有可能会产生新的垃圾。

4. 并发清除
   - 清除阶段是清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发进行的。

**CMS 的问题：**

**1. 并发回收导致CPU资源紧张：**

在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程而导致应用程序变慢，降低程序总吞吐量。CMS默认启动的回收线程数是：`（CPU核数 + 3）/ 4`，当CPU核数不足四个时，CMS对用户程序的影响就可能变得很大。

**2. 无法清理浮动垃圾：**

在CMS的并发标记和并发清理阶段，用户线程还在继续运行，就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留到下一次垃圾收集时再清理掉。这一部分垃圾称为“浮动垃圾”。

**3. 并发失败（Concurrent Mode Failure）：**

由于**在垃圾回收阶段用户线程还在并发运行**，那就还**需要预留足够的内存空间提供给用户线程使用**，因此CMS不能像其他回收器那样等到老年代几乎完全被填满了再进行回收，**必须预留一部分空间供并发回收时的程序运行使用**。
默认情况下，当老年代使用了 92% 的空间后就会触发 CMS 垃圾回收，这个值可以通过 `-XX**:** CMSInitiatingOccupancyFraction` 参数来设置。

这里会有一个风险：要是**CMS运行期间预留的内存无法满足程序分配新对象的需要**，就会出现一次“并发失败”（`Concurrent Mode Failure`）
这时候虚拟机将不得不启动后备预案：`Stop The World`，临时启用 `Serial Old` 来重新进行老年代的垃圾回收，这样一来停顿时间就很长了。

**4.内存碎片问题：**

CMS是一款基于“标记-清除”算法实现的回收器，这意味着回收结束时会有内存碎片产生。内存碎片过多时，将会给大对象分配带来麻烦，往往会出现**老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象**，而不得不提前触发一次 Full GC 的情况。

为了解决这个问题，CMS收集器提供了一个 
`-XX**:**+UseCMSCompactAtFullCollection` 开关参数（默认开启），用于在 Full GC 时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，是无法并发的，这样停顿时间就会变长。
还有另外一个参数 `-XX**:**CMSFullGCsBeforeCompaction`，这个参数的作用是要求CMS在执行过若干次不整理空间的 Full GC 之后，下一次进入 Full GC 前会先进行碎片整理（默认值为0，表示每次进入 Full GC 时都进行碎片整理）。

## 详细说一下G1的回收过程？

G1（Garbage First）回收器采用**面向局部收集**的设计思路和**基于Region的内存布局形式**，是一款主要面向服务端应用的垃圾回收器。

G1设计初衷就是替换 CMS，成为一种全功能收集器。
G1 在JDK9 之后成为服务端模式下的默认垃圾回收器，取代了 Parallel Scavenge 加 Parallel Old 的默认组合，而 CMS 被声明为不推荐使用的垃圾回收器。

G1从整体来看是基于 **标记-整理** 算法实现的回收器，但从局部（两个Region之间）上看又是基于 **标记-复制** 算法实现的。

**G1 回收过程**，G1 回收器的运作过程大致可分为四个步骤：

1. 初始标记（STW）
   - 仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。
   - STW耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。

2. 并发标记：
   - 从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象
   - 这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理在并发时有引用变动的对象。

3. 最终标记（STW）
   - 对用户线程做短暂的暂停，处理并发阶段结束后仍有引用变动的对象。

4. 清理阶段（会STW）
   - 这里的操作涉及存活对象的移动，必须暂停用户线程，由多条回收器线程并行完成的。
     1. 更新Region的统计数据，**对各个Region的回收价值和成本进行排序**，
     2. 根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集
     3. 然后把决定回收的那一部分Region的**存活对象复制到空的Region**中
     4. 再清理掉整个旧Region的全部空间。
   


## 三色标记法知道吗

三色标记法是应用于CMS、G1等垃圾回收器的**并发标记算法**，它最大的特点是**可以异步执行**，而其他垃圾处理器在根节点枚举这一步骤是必须暂停用户线程的

事先约定：
- 白色：表示对象尚未被垃圾收集器处理过
  - 在可达性分析开始阶段，所有对象都是白色的
  - 如果可达性分析结束时仍为白色，说明对象不可达
- 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用没有被扫描过
  - 说明正在扫描
- 黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都被扫描过了
  - 黑色对象是安全的，不会被回收
  > 黑色对象不可能直接引用白色对象

**初始状态**，所有的对象都是白色的，只有 GC Roots 是黑色的。

![](./../images/JVM/三色标记-初始.jpg)

GC Roots标记**直接关联的对象为灰色**

**并发标记阶段**，扫描整个引用链
- 没有子节点的话，将本节点变为黑色。
- 有子节点的话，则**当前节点变为黑色，子节点变为灰色**

之后，重复进行并发标记，直到灰色对象没有其他子节点引用时，结束。

![](./../images/JVM/并发标记.jpg)

**扫描完成**，黑色的对象为存活的对象，白色的对象是可回收的对象

![](./../images/JVM/扫描完成.jpg)

**三色标记法的缺陷**
- 多标（指多标了黑色的，**浮动垃圾**）
  - 假设已经遍历到 E（变为灰色了），此时应用执行了 objD.fieldE = null (D > E 的引用断开)。
    此时，E、F、G对象不可达，应当被回收，但由于E是灰色的，导致它们也会标记位黑色
  - 另外，针对并发标记开始后的新对象，通常的做法是直接全部标记为黑色，在本轮不清除，这也是**浮动垃圾**的一部分  

![](./../images/JVM/多标.jpg)

- 漏标
  - 假设 GC 线程已经遍历到 E（变为灰色了），此时应用线程先执行了`var G = objE.fieldG;` 与 `objE.fieldG = null;`，导致**灰色E断开对白色G的引用，而已扫描完成的D引用了G**
  - D已完成扫描，不会再扫描，导致G一直是白色的，并作为垃圾被清除，这是不能接受的

![](./../images/JVM/漏标.jpg)

漏标的条件主要体现在以下三步代码中
```java
var G = objE.fieldG; // 1.读
objE.fieldG = null; // 2.写
objD.fieldG = G; // 3.写
```
只要在上面三步中的任意一个，将对象G记录起来，在**重新标记**阶段，作为灰色对象遍历即可

> 重新标记阶段仍然是需要STW的，三色标记法没有完全消除STW，只是尽可能缩短了STW的时间

针对于漏标问题，JVM 团队采用了**读屏障**与**写屏障**的方案：
- 加入读屏障，拦截第一步
  - 当读取成员变量之前，先将其记录下来
  - 这种做法是保守的，但也是安全的。因为条件一中【一个或者多个黑色对象重新引用了白色对象】，重新引用的前提是：得获取到该白色对象，此时已经读屏障就发挥作用了
- 加入写屏障，拦截第二、三步
  - 所谓的写屏障，其实就是指给某个对象的成员变量赋值操作前后，加入一些处理

而不同垃圾收集器对漏标的处理方法也是不同的：
- CMS：写屏障+增量更新
- G1：写屏障+原始快找
- ZGC：读屏障

拦截的目的：**在读写前后，将对象 G 给记录下来**




## JVM中一次完整的GC是什么样子的？

先描述一下Java堆内存划分。

在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )，新生代默认占总空间的 `1/3`，老年代默认占 `2/3`。
新生代有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1。

新生代的垃圾回收（又称Minor GC）后只有少量对象存活，所以选用复制算法，只需要少量的复制成本就可以完成回收。

老年代的垃圾回收（又称Major GC）通常使用“标记-清理”或“标记-整理”算法。

![](http://blog-img.coolsen.cn/img/image-20210329225348086.png)

再描述它们之间转化流程：

* 对象优先在Eden分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。

  1. 在 Eden 区执行了第一次 GC 之后，存活的对象会被移动到其中一个 Survivor 分区；
  2. Eden 区再次 GC，这时会采用复制算法，将 Eden 和 from 区一起清理，存活的对象会被复制到 to 区；

  - 每移动一次，对象年龄加 1，**对象年龄大于一定阀值会直接移动到老年代**。GC年龄的阀值可以通过参数 -XX:MaxTenuringThreshold 设置，默认为 15；
  - **动态对象年龄判定**：Survivor 区相同年龄所有对象大小的总和 > (Survivor 区内存大小 * 这个目标使用率)时，大于或等于该年龄的对象直接进入老年代。其中这个使用率通过 -XX:TargetSurvivorRatio 指定，默认为 50%；
  - Survivor 区内存不足会发生**担保分配**，**超过指定大小的对象可以直接进入老年代**。

* **大对象直接进入老年代**，大对象就是需要大量连续内存空间的对象（比如：字符串、数组），为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。

* 老年代满了而**无法容纳更多的对象**，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – **包括年轻代和老年代**。

## Minor GC 和 Full GC 有什么不同呢？

Minor GC：只收集新生代的GC。

Full GC: 收集整个堆，包括 新生代，老年代，永久代(在 JDK 1.8及以后，永久代被移除，换为metaspace 元空间)等所有部分的模式。

**Minor GC触发条件：** 当Eden区满时，触发Minor GC。

**Full GC触发条件**：


1. 调用System.gc()
   - 但这是**建议虚拟机执行`Full GC`**，并不一定执行
2. 老年代空间不足
   - 即由之前说的大对象、长期存活对象进入老年代引发的空间不足。
   - 应该当尽量不创建过大的对象或数组。
   - 同时可以用`-Xmn`**调整新生代大小，让对象尽量在新生代被回收掉**；
   - 也可以通过`XX:MaxTenuringThreshold`**调大对象进入老年代的年龄**
3. 空间分配担保失败
   - 使用==标记-复制==算法的 `Minor GC` 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC
4.  ==JDK1.7前==的永久代空间不足
       - 在此之前，HotSpot的方法区是通过永久代实现的，永久代存放Class的信息、常量、静态变量等改变频率较低的信息。
       - 如果永久代被占满，在未配置为采用`CMS GC`的情况下也会执行`Full GC`。
       - 如果经过 Full GC 仍然回收不了，那么虚拟机会抛出`java.lang.OutOfMemoryError` 
5. Concurrent Mode Failure
   - 执行`CMS GC`的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是**GC 过程中浮动垃圾过多导致暂时性的空间不足**），便会报`Concurrent Mode Failure`错误，并触发`Full GC`

## 介绍下空间分配担保原则？

如果MinorGC时，新生代有大量对象存活下来，而 **survivor 区放不下了**，这时必须转移到老年代中，但这时发现**老年代也放不下这些对象了**，那怎么处理呢？其实JVM有一个老年代空间分配担保机制来保证对象能够进入老年代。

- 在 Minor GC 之前，虚拟机先检查**老年代最大可用的连续空间是否大于新生代所有对象总空间**，如果条件成立的话，那么 Minor GC 可以确认是安全的。
- 如果不成立（最大可用连续空间小于新生代所有对象总空间），查看`HandlePromotionFailure`的值是否允许**担保失败**。
  - 如果**允许担保失败**，那么就会继续检查**老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小**
    - 如果大于，将尝试着进行一次 `Minor GC`；
    - 如果小于，或 `HandlePromotionFailure` 的值不允许冒险，那么就要进行一次 Full GC。
> 也就是Minor GC的要求：老年代可用连续空间能容得下新生代的所有对象，如果小于，若允许担保失败，则比较老年代可用连续空间是否大于历次晋级的平均大小





## 为什么要有survivor区？其作用是什么（防止碎片化）

> 注意：在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )，新生代默认占总空间的 1/3，老年代默认占 2/3。
> 新生代有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1。
> 在空间分配担保后的Minor GC中，如果存活对象的大小大于Survivor的剩余空间，则直接放入老年代

现在垃圾收集器通常将堆划分为新生代与老年代，其中新生代占比较小，老年代占比较大；
而新生代又划分为Eden、To Survivor 与 From Survivor。

对象创建时通常处于新生代，如果在一定次数的GC之后对象仍然存活，则将其移入老年代，创建Survivor分区的目的就是存放这些存活了一定次数GC的对象。

如果没有Survivor分区，直接将对象存储在新生代中，就只能将对象送入老年代，这样就会导致老年代的空间占用增大，使得Full GC更加频繁

## survivor区为什么分为to区与form区？为什么不分为三个区或四个区

分为两个区最主要的目的就是为了防止内存空间碎片化。

如果只设置一个Survivor，当Eden满了，触发一次Minor GC，Eden存活的对象被送入Survivor，这样循环往复。
在下一次Eden满，触发Minor GC时，此时Eden与Survivor都存放着一些对象，**如果此时把Eden区的存活对象复制到Survivor区，很明显这两部分对象所占有的内存是不连续的，它们之间总会产生较小的内存碎片，也就导致了内存碎片化**，久而久之，导致堆中没有足够大的连续内存来容纳对象
![](./../images/JVM/GC碎片.jpg)

通过建两个区（from 与 to），可以解决这个问题。GC流程如下：
- 新建的对象置于Eden区，经过一次Minor GC，存活对象被移动到其中一个Survivor，Eden被清空；
- 等Eden再次满了，进行下一次Minor GC，Eden与之前的Survivor中的幸存对象就会被送入另一块Survivor。从而使得Eden与先前的Survivor中的对象能够连续地存储，避免了内存碎片。

但如果再分下去，每个Survivor的空间就会比较小，或者Survivor占用的空间较多，得不偿失。

## GCRoots有哪些，判断GC Roots的原则是什么

 GC roots：
- 虚拟机栈中局部变量表引用的对象
- 本地方法区中，本地方法引用的对象
- 方法区中，静态变量引用的对象
- 方法区中，常量引用的对象
- 被用于同步的各种锁对象
- JVM自身持有的对象，例如系统类加载器

> Tracing GC的根本思路就是：
> 给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，其余对象（也就是没有被遍历到的）就自然被判定为死亡。


## 类的属性会造成内存泄漏么，那他适合做GCRoot么，为什么类的成员变量不可以作为GCRoot

所谓内存泄漏，就是不再使用的对象的内存空间长时间不被回收，无法再次利用。

类的属性分为静态对象与非静态对象两种，前者的引用存放于方法区中（JDK1.8之后，存放到堆中），但其实例仍然在堆中，后者存放于堆或栈中，而前者的引用本身就作为GC Roots，后者随着类一起存放。

类的成员变量不适合作为GC Roots，因为类的成员变量的生命周期与其所属的实例相同，如果以实例的成员变量为GC Roots，就会导致这个实例不被回收。

## 什么情况下会发生内存泄漏

1. 使用了静态集合类
   - 如HashMap、LinkedList等，如果这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏
   - 简而言之，**长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收**
2. 各种连接，如数据库连接、网络连接和IO连接
   - 不再使用连接时，应当及时断开，让垃圾回收器来回收
3. 变量不合理的作用域
   - 一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏
   - 没有及时设置为null，也会造成内存泄漏
4. 内部类持有外部类
   - 如果一个外部类的实例对象的方法**返回了一个内部类的实例对象**，这个内部类对象被长期引用了。即使那个外部类实例对象不再被使用，但由于**内部类持有外部类的实例对象**，这个外部类对象将不会被垃圾回收       
5. 插入HashMap等集合后，修改key对象中参与hashcode的计算的字段
   - 这也是不能使用可变类作为key的原因 
6. 将对象放入缓存中后，忘了清除
   - 可以用WeakHashMap防止泄露，此key没有其他引用那么此map会自动丢弃此值
7. 监听器和其他回调 
8. ThreadLocal

## 垃圾回收的安全点是哪些，安全区域是什么

程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint） ”

安全回收的条件：
1. 堆内存的变化是受控制的，最好所有的线程都停止
2. 堆中的对象和对象的状态是可知的

安全点通常应该选择执行时间较长的指令作为安全点：
- **调用方法的call之后**
- **方法返回前**
- **循环的末尾**
- **抛出异常的位置**

> 当程序不执行，例如处于Sleep或Blocked状态，**无法响应虚拟机的中断请求，不能到达安全点**，所以引入安全区域来解决这个问题。
> 
> 安全区域是指能够确保在某一段代码片段之中，**引用关系不会发生变化**，因此，在这个区域中任意地方开始垃圾收集都是安全的。
> 
> 线程执行到安全区域的代码时，会标识自己进入安全区域。离开时检查虚拟机是否已完成根节点的枚举。未完成则等待

## 如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？

- **抢先式中断**
  - **不需要线程的执行代码主动去配合**
  - 在垃圾收集发生时，**系统首先把所有用户线程全部中断**。
    - 如果发现有用户线程中断的地方不在安全点上，就**恢复这条线程执行**，让它一会再重新中断，直到跑到安全点上
- **主动式中断**
  - 当垃圾收集需要中断线程的时候，**不直接对线程操作**，仅仅简单地设置一个**标志位**，各个线程执行过程时会**不停地主动去轮询这个标志**，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。
  > 轮询标志的地方和安全点重合，还要加上所有创建对象和其他需要在Java堆分配内存的地方（为了检查是否即将要发生垃圾收集，避免没有内存分配给新对象）

## 怎么避免内存泄漏？

物理连接、饿汉式单例、ThreadLocal、静态集合

## 什么是大对象，大对象过多会产生什么现象

大对象即需要大量连续内存空间的对象，而在垃圾回收算法中，大对象指的是占用内存大于指定阈值的对象；G1垃圾回收器中，大对象的定义为大小超过Region容量一半的对象，

## 为什么垃圾回收次数发生很多会不好

因为绝大多数垃圾回收算法都是需要**暂停用户线程**的，会导致用户的体验不佳，或造成CPU资源的浪费，且部分垃圾回收算法会导致内存碎片的产生。

## 在一个for循环中每次都需要建立一个很大的对象，这一个对象就快把内存占满了，不想每次都发生GC又不想每次都重新设置该怎么办。

- 对大对象进行优化，将大对象分解为多个小对象，这样就可以降低对大量连续内存空间的需求
- 使用Cache与Pool保存大对象，当需要创建对象时，直接从其中取出一个对象，修改其属性值，作为创建对象的替代

## 永久代涉及GC回收吗

永久代是**JDK8之前方法区的存储形式**，保存的是静态变量、常量、类的信息等数据，**垃圾回收会发生在永久代**，如果永久代满了或者是超过了临界值，会触发完全垃圾回收 (Full GC)

永久代回收条件：
- 对**类**的回收
  - 该类的实例都被回收
  - 该类的ClassLoader已被回收
  - 该类不能通过反射访问到其方法，且该类的java.lang.class没有被引用
- 对**废弃常量**的回收
  - 例如字符串“123”，如果系统内没有任何变量使用这个字符串，则会被回收


## 说一下 JVM 调优的命令？

* **jps**（显示虚拟机进程）
  * JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。
* **jstat**（检视虚拟机进程状态）
  * jstat(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。
* **jmap**
  * jmap(JVM Memory Map)命令用于生成heap dump文件，如果不使用这个命令，还阔以使用-XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候·自动生成dump文件。
  jmap不仅能生成dump文件，还阔以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。
* **jhat**
  * jhat(JVM Heap Analysis Tool)命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。在此要注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析。
* **jstack**（生成线程快照）
  * jstack用于生成java虚拟机当前时刻的线程快照。
  * jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 
  * 如果java程序崩溃生成`core`文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。

## 内存什么时候会出现一个锯齿状的波动，举一例子，为什么会造成这种情况？内存的波形图是很小的锯齿形和很大的锯齿形比起来那种好，为什么好，为什么不好？那波动很大怎么解决？

出现锯齿状的波动说明发生了垃圾回收，使得内存的占用减少了，而频繁出现波动，说明对象的创建与回收太频繁了

小的锯齿比较好，

## 如果系统cpu飙升，如何排查(中间还扯到死锁，也把死锁讲了一下)
https://zhuanlan.zhihu.com/p/339861666

CPU占用飙升的原因：
1. 死循环导致的CPU高密度计算
2. JVM进行GC但释放的空间不多，频繁GC导致CPU占用飙升
3. 自旋的非阻塞死锁导致CPU占用升高

排查方法：
1. 通过top、htop命令，找到占用cpu最高的进程
2. 通过`ps -mp pid -o THEAD,tid | sort -r`，查询指定进程中的线程列表，并查看其中CPU占用最高的几个线程
3. 通过`jstack pid | grep tid -A 50`根据线程ID查找线程堆栈信息，即可得知线程中的方法运行的情况，从而判断是哪里出现了问题

# 类加载

## 类加载机制(不断的深挖，中间还问到了mysql的Driver如何破坏双亲委派机制的，类加载器的命名空间)



## 什么是类加载？类加载的过程？

虚拟机**把描述类的数据加载到内存里面，并对数据进行校验、解析和初始化，最终变成可以被虚拟机直接使用的class对象**，这一过程即类加载；

![image-20210329231258940](http://blog-img.coolsen.cn/img/image-20210329231258940.png)

加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：**解析在某些情况下可以在初始化阶段之后再开始**，这是为了支持Java语言的**运行时绑定**（也称为动态绑定或晚期绑定）

类加载过程如下：

* 加载，加载分为三步：
  1、通过**类的全限定性类名**获取该类的二进制流；
  2、将该二进制流的静态存储结构转为**方法区的运行时数据结构**；
  3、在堆中为该类**生成一个class对象**；

* 验证：验证该class文件中的字节流信息是否符合虚拟机的要求，不会威胁到jvm的安全；

* 准备：为class对象的**静态变量分配内存**，初始化其初始值；

* 解析：该阶段主要完成**符号引用转化成直接引用**；

* 初始化：到了初始化阶段，才开始执行类中定义的java代码；初始化阶段是调用类构造器的过程；


## 类加载过程是不是线程安全的

ClassLoader的`loadClass`方法在加载类的时候使用了`synchronized`关键字。
除非被重写，这个方法默认在整个装载过程中都是线程安全的。

## 什么时候会触发类的加载，什么时候触发类的卸载

类加载的时机：**第一次需要使用类信息时**加载
> 加载原则：延迟加载，能不加载就不加载

虚拟机规范并未严格规定类加载的时机，跟具体的JVM虚拟机有关。
类加载的最佳时机是**解析字节码（class文件）中常量池符号的时候**，`Class.forName()`、`ClassLoader.loadClass()`、`反射API`和`JNI_FindClass`都可以触发类加载，Hot JVM自身启动的时候也会触发类加载。


永久代回收条件：
- 对**类**的回收
  - 该类的实例都被回收
  - 该类的ClassLoader已被回收
  - 该类不能通过反射访问到其方法，且该类的java.lang.class没有被引用
- 对**废弃常量**的回收
  - 例如字符串“123”，如果系统内没有任何变量使用这个字符串，则会被回收

## 类初始化时机

JVM并没有规定何时开始类加载过程的第一个阶段（加载），但JVM规定了六种必须执行初始化的场景（有且只有这六种场景）：

1. 主动引用
   - 遇到`new`、`getstatic`、`putstatic`或`invokestatic`这四条字节码指令时，如果类没有初始化，则需要先触发其初始化阶段。
        > 生成这四条指令的典型Java代码场景有：
        > - 使用`new`关键字实例化对象
        > - 读取或设置一个类型的**静态字段**（**被final修饰、已在编译期把结果放入常量池的静态字段除外**）
        > - 调用一个类型的**静态方法**
   - 使用`java.lang.reflect`包的方法对类型进行**反射调用**时，如果类未经初始化，需要先触发其初始化
   - 初始化类时，发现其**父类未经初始化**，需要先触发其父类的初始化
   - 虚拟机启动时，用户需要指**定一个要执行的主类（包含main()方法的类）**，**虚拟机会先初始化这个主类**
   
        > 还有两种额外的情况：
        > - 当一个接口定义了JDK8加入的**默认方法**（default修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那么**这个接口要在其之前进行初始化**
        > - 当使用JDK7加入的动态语言支持时，如果一个`java.lang.invoke.MethodHandle`实例最后的解析结果为`REF_getStatic`、`REF_putStatic`、`REF_invokeStatic`、`REF_newInvokeStatic`四种类型的方法句柄，并且这个方法句柄对应的类没有初始化，需先触发其初始化

> 注意：
> - 当访问类的final static修饰的==变量==时，不会触发类的初始化；但调用final static的==成员方法==时，会触发类的初始化！一定要和静态且final修饰的变量区分开！！
> - 但是静态属性 有final修饰 时也有情况会被加载
>   > `public static final int a=getNum();`这样也会被加载。`getNum()`是静态方法，并且不管这个静态方法是子类的还是父类的；
> - 类的加载成功后，即静态成员都被加载后，是不会再加载第二次的。只有非静态成员，如非静态成员变量、非静态代码块、非静态方法(不调用不加载)、构造方法**都会在被多次实例化的时候多次加载**。

2. 被动引用
   - 以上六种场景被称为**对一个类型进行主动引用**。除此之外，所有引用类型的方法**都不会触发初始化**，称为被动引用。
   - 被动引用包含以下情形：
     - 子类引用父类的静态字段
       - 对静态字段，只有直接定义这个字段的类才会被初始化
     - 通过数组定义来引用类
       - 类的数组并不触发该类的初始化，而是触发另一个由虚拟机自动生成、直接继承Object的类的初始化，这个类代表了元素类型为原始类的一维数组
     - 引用常量
       - 常量在编译阶段存入调用类的常量池中，本质上没有引用定义常量的类


### 被动引用 - **通过子类引用父类的静态字段**，不会导致子类初始化，而是触发父类的初始化与子类的加载
```java
public class SuperClass {
    static {
        System.out.println("SuperClass init!");
    }
    public static int value = 123;
}

public class SubClass extends SuperClass {
    static {
        System.out.println("SubClass init!");
    }
}

System.out.println(SubClass.value);
```
只会输出"SuperClass init!"。
因为对于静态字段，只有**直接定义这个字段的类才会被初始化**，因此通过子类来引用父类中定义的静态字段，**只会触发父类的初始化**

### 被动引用 - 通过数组定义来引用类，不会触发此类的初始化


```java
//沿用上面的SuperClass
SuperClass[] sca = new SuperClass[10];
```

这里并没有输出"SuperClass init!"，因为此处并没有触发类com.test.SuperClass的初始化，实际上触发了另一个`[Lcom.test.SuperClass`的类的初始化，它是虚拟机自动生成的，直接继承Object的类。
这个类代表了一个元素类型为`com.test.SuperClass`的一维数组，数组中应有的属性和方法都包装在这个类中。

#### 被动引用 - 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化

```java
public class ConstClass {
    static {
        System.out.println("ConstClass init!");
    }
    public static final String HELLOWORLD = "hello world";
}

System.out.println(ConstClass.HELLOWORLD);
```

这段代码则**没有**输出"ConstClass init!"
因为在编译阶段，通过常量传播优化，将此常量的值"hello world"直接存储在`NotInitialization`类的常量池中，该类对常量`ConstClass.HELLOWORLD`的引用都会转化为对自身类常量的引用。
也就是说这两个类在编译后已经不存在任何联系了。


## 什么是类加载器，常见的类加载器有哪些？

类加载器是指：通过一个类的全限定性类名获取该类的二进制字节流叫做类加载器；类加载器分为以下四种：

* 启动类加载器（BootStrapClassLoader）：
  * 用来加载**java核心类库**，无法被java程序直接引用；

* 扩展类加载器（Extension ClassLoader）：
  * 用来加载**java的扩展库**，java的虚拟机实现会提供一个扩展库目录，该类加载器在扩展库目录里面查找并加载java类；

* 系统类加载器（Application/System ClassLoader）：
  * 它**根据java的类路径来加载类**，一般来说，java应用的类都是通过它来加载的；

* 自定义类加载器：
  * 由java语言实现，继承自`ClassLoader`；

![](http://blog-img.coolsen.cn/img/image-20210329231439914.png)

## 启动类加载的方式有哪些

- 令行启动应用时候由JVM初始化加载

- 通过`Class.forName()`方法动态加载

- 通过`ClassLoader.loadClass()`方法动态加载
> `Class.forName()`和`ClassLoader.loadClass()`区别
> 
> `Class.forName()`：**将类的`.class`文件加载到jvm中，并对类进行解析，执行类中的`static`块**；
> `ClassLoader.loadClass()`：**只干一件事情，就是将`.class`文件加载到jvm中，不会执行`static`中的内容,只有在`newInstance`才会去执行`static`块**
> - `Class.forName(name,initialize,loader)`带参函数也可控制是否加载static块。并且只有调用了`newInstance()`方法采用调用构造函数，创建类的对象 

## 什么是双亲委派模型？为什么需要双亲委派模型？

当一个类加载器收到一个类加载的请求，他首先不会尝试自己去加载，而是将这个请求委派给父类加载器去加载，只有父类加载器在自己的搜索范围类查找不到给类时，子加载器才会尝试自己去加载该类；

JVM认为两个对象相同，需要符合以下条件：
- 这两个对象是通过同名的类完成实例化的
- 两个实例对应的同名的类，是使用相同的类加载器加载的。

为了**保证系统的安全**，对于`java.lang.Object`这种核心类，JVM需要保证它们的对象都会被认定为同一类型，所以需要让相同的类加载器来加载`Object`

除此之外，也是为了保证`java.lang.String`这种类的唯一性与安全性
因为如果没有双亲委派的话，用户就可以自己定义一个`java.lang.String`类，那么就无法保证类的唯一性，也会出现各种奇怪的bug

同时，在双亲委派模型的帮助下，也可以**防止重复进行类加载，造成无意义的开销**

## **那怎么打破双亲委派模型**？

自定义类加载器，继承`ClassLoader`类，重写`loadClass`方法和`findClass`方法，即可打破双亲委派模型。

> 双亲委派的逻辑是写在findClass方法中的

## 列举一些你知道的打破双亲委派机制的例子，为什么要打破？

- Tomcat，应用的类加载器**优先自行加载应用目录下的 class**，并不是先委派给父加载器，加载不了才委派给父加载器。

  tomcat之所以造了一堆自己的classloader，大致是出于下面三类目的：

  1. webapp私有类的共享与共有类的隔离
     - 对于各个 `webapp`中的 `class`和 `lib`，需要相互隔离，不同的应用程序可能会依赖**同一个第三方类库的不同版本**，**不能要求同一个类库在同一个服务器只有一份**，因此要保证每个应用程序的类库都是独立的，保证相互隔离。
     - 在此基础上，部署在同一个web容器中相同的类库相同的版本在不同的应用程序间可以共享 
  2. tomcat容器私有类与webapp类的隔离
     - web容器也有自己依赖的类库，不能于应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库隔离开来。
  3. 热部署
     - 可以仅修改webapp私有类，不影响tomcat容器的运行 

  tomcat类加载器如下图：

  ![](./../images/JVM/tomcat.png)

  - 其中，JVM原有的启动类加载器、扩展类加载器、应用程序类加载器不变，其负责加载的Class可以被Tomcat容器与所有Webapp访问
  - CommonClassLoader
    - Tomcat的基本类加载器，加载的Class同样可以被Tomcat容器与所有Webapp访问
  - CatalinaClassLoader
    - 容器私有的类加载器，加载路径中的class对webapp不可见
  - SharedClassLoader
    - 各个Webapp共享的类加载器，对所有webapp可见，但对tomcat容器不可见
  - WebappClassLoader：
    - webapp私有的类加载器，只对当前webapp可见
- MySQL的Driver


## 双亲委派和打破双亲委派（自己写个 String 类能加载吗，之前的 String 是什么时候加载进去的）

不能加载，因为应用程序类加载器会委派给扩展类加载器，扩展类加载器又委派给启动类加载器，但启动类加载器在 `<JRE_HOME>/lib/rt.jar`下找到了重名的`java.lang.Stirng` ，于是返回的是启动类加载器加载的原有的`java.lang.String`

双亲委派模型是实现于类加载器的`loadClass()`方法中的，如果调用父加载器无法加载成功，才会使用自己的`findClass()`尝试加载。

```java
public class String {
    public static void main(java.lang.String[] args) {
        System.out.println("我是自定义的String");
    }
}
```

这里我们把`main()`方法的参数修改为了正确的`java.lang.String[] args`，防止重名，发现是能够正常运行的。
但如果覆写的package是`java.lang`，即想要覆盖原来的`java.lang.String`，则会提示==找不到main()方法==，因为被系统类加载器拦截了。
如果通过自定义类加载器，重写`loadClass()`方法，可以通过编译，但会报一个安全异常

## 魔数是什么

魔数：每个Class文件的**头4个字节**，唯一的作用是确定这个文件是否为一个能被虚拟机接受的Class文件。
>Class文件的魔数为：`0xCAFEBABE`（咖啡宝贝）

## 在一个类中调用了另一个类的私有方法，能否通过编译？

不能通过编译，会在**验证阶段的符号引用验证**上出错（符号引用验证其实是验证阶段的，但是到解析阶段才会执行）

## NoClassDefError和ClassNotFoundException有什么区别？

- NoClassDefError
  - 发生在编译后的运行期间（通常是类加载期间），由于是Error，不需要程序考虑怎么Catch
  - 发生原因：JVM在动态运行时，**编译时能找到合适的类**，而在==运行时==，**java的ClassPath里不能找到合适的类**导致的错误。
   - 例如在运行时我们想调用某个类的方法或者访问这个类的静态成员的时候，发现这个类不可用，此时Java虚拟机就会抛出NoClassDefFoundError错误。
  - 解决方案：
    1. 检查jar包是否成功导入，或jar包的名称是否正确
    2. 运行时明确指定你认为程序能正常运行的 -classpath 参数，判断是不是classpath被覆盖了 
- ClassNotFoundException
  - 非RuntimeException（CheckedException），在编译前就会检查出该错误
  - 发生原因：当程序运行过程中，尝试使用类加载器去动态加载Class文件，如果没有在classpath中查找到指定的类，就会抛出ClassNotFoundException
    - 例如使用`Class.forName()`或者`ClassLoader.loadClass()`以及使用`ClassLoader.findSystemClass()`加载类而没有找到
  - 解决方案
    1. 检查环境变量中的classpath，查看所需要的类库是否在路径下
    2. 是否使用了重复的类库，且版本不一致
    3. java运行环境的jdk版本是否比class文件的编译版本低
    4. 类名打错了

## 有一个A.jar与B.jar，他们互相引用了对方，如果B.jar中的某些类不在了，A还能启动吗？

不能启动，会在类加载期间出现NoClassDefError

## ldc，iconst，getstatic，ACC_FLAG这几个指令是什么意思



## 重载与重写的区别

重载：重载即函数重载，在Java的同一个类中，可以有多个函数名相同的函数，==只要它们的参数不同即可==。
重载的原理是JVM的==静态分派==，即JVM在确定同名方法的具体版本时，是根据其参数的静态类型判断，且该类型在编译期可知
`Human man = new Man()`静态类型：Human，实际类型：Man

重写Override：子类对父类的允许访问的方法的实现过程进行重新编写。要求==返回值与形参都不能改变==
重写的原理是JVM的==动态分派==，即**Java的虚方法的版本会在运行过程中动态地确定**


## 方法调用


方法调用并不等于方法中的代码被执行。
方法调用阶段的唯一任务即：**确定被调用方法的版本（即调用哪一个方法）**，暂时还未涉及方法内部的具体过程。

而之前也提到了，**Class文件的编译过程中不包含传统程序语言编译的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用**，而不是方法在实际运行时内存布局中的入口地址（即直接引用）


### 解析

前面提到过，所有方法调用的目标方法在Class文件中存储的都是**符号引用**，在类加载的==解析==阶段，会**将其中的一部分符号引用转化为直接引用**。
这种解析能够成立的前提是：**方法在程序真正运行之前就有一个可确定的调用版本，而且这个方法在运行期是不可改变的**，即==编译期可知，运行期不可变==。

换句话说，调用目标在程序代码写好、编译器进行编译的那一刻就已经确定下来了，**这类方法的调用被称为解析**

在Java语言中，符合**编译期可知，运行期不可变**的方法有：
- ==静态方法==：静态方法与类直接关联
- ==私有方法==：私有方法在外部无法访问
  
二者的特点决定了它们**不可能通过继承或别的方式重写出其他版本**，因此都适合在**类加载阶段**进行解析

> 在Java语言里，共有五种方法能够被JVM的`invokestatic`和`invokespecial`字节码指令调用，即**可以在解析阶段确定唯一的调用版本**的方法：
> - 静态方法
> - 私有方法
> - 实例构造器`<init>()`方法 
> - 类的父类方法
> - 被final修饰的方法(使用`invokevirtual`调用)。
> 它们在类加载的时候可以把符号引用解析为该方法的直接引用，称为**非虚方法**，其他方法称为**虚方法**

而另一种主要的方法调用方式：分派（Dispatch）调用则复杂得多。

### 分派

分派可能是静态或动态，按照分派依据的宗量数又可分为单分派与多分派

>分派这个词本身就具有动态性，一般不应用于静态语境中

#### 静态分派

静态分派的典型应用就是方法**重载**。
由于静态分派发生在编译阶段，因此确定静态分派的动作实际上**不是由虚拟机来执行的**，因此一些资料将它划分为解析

```java
public class StaticDispatch {
    static abstract class Human{
    }
    static class Man extends Human{}
    static class Woman extends Human{}
    public void sayHello(Human guy){
        System.out.println("Hello Guy");
    }
    //重载
    public void sayHello(Man guy){
        System.out.println("Hello gentleman!");
    }
    public void sayHello(Woman guy){
        System.out.println("Hello Lady!");
    }

    public static void main(String[] args) {
        //1. 多态
        //其中Huamn称为变量的静态类型（Static Type）或外观类型（Apparent Type）
        //而Man称为变量的实际类型（Actual Type）或运行时类型（Runtime Type）
        //其中，静态类型的变化仅仅在使用时发生，变量本身的静态类型是不会改变的，并且最终的静态类型在编译期可知
        //而实际类型变化的结果在运行期才可知。
        Human man = new Man();
        Human woman = new Woman();
        StaticDispatch sr = new StaticDispatch();
        //3. 虚拟机（更准确来说是编译器）在重载时是根据参数的静态类型来判断的，称为静态分派
        sr.sayHello(man);//Guy
        sr.sayHello(woman);//Guy

        //2. 实际类型变化，必须要等到运行时才可以确定
        Human human = (new Random()).nextBoolean() ? new Man() : new Woman();
        //静态类型变化，编译期就可知
        sr.sayHello((Man) human);
        sr.sayHello((Woman) human);
    }
}
```

#### 动态分派

动态分派与==重写Override==息息相关

>invokevirtual指令的运行时解析过程如下：（这里其实和类加载阶段的方法解析类似，但是invokevirtual没有在接口中搜索）
>
>1. 找到**操作数栈顶的第一个元素指向对象的实际类型**，记作C
>2. 如果在类型C中，找到了与常量中的描述符和简单名称都匹配的方法，则进行访问权限校验，如果通过，则直接返回这个方法的直接引用，不通过则返回java.lang.IllegalAccessError异常
>3. 否则，按照继承关系从下往上对**C的父类**进行第二步的搜索和验证
>4. 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常

由于`invokevirtual`指令的第一步就是**在运行期确定接受者的实际类型**，所以两次调用中的`invokevirtual`**并不是把常量池中方法的符号引用解析到直接引用就结束了**，还会==根据方法接收者的实际类型选择方法版本==，这个过程就是Java语言中重写的本质。

把这种==在运行期根据实际类型确定方法执行版本==的分派过程称为动态分派

> 由于重写的多态性源自虚方法调用指令invokevirtual的执行逻辑，所以重写只对方法有效，对字段无效。
> 同时，由于字段不可能是虚的，一个类的方法访问某个名字的字段时，该名字指的就是这个类能看到的那个字段，如果子类声明了与父类同名的字段，虽然**在子类的内存中两个字段都会存在，但子类的字段会屏蔽父类的同名字段**，也自然不会参与到多态中。

```java
//执行顺序：父类构造器->变量初始化->代码块->构造器
public class FieldHasNoPolymorphic {
    static class Father {
        public int money = 1;
        public Father() {
            money = 2;//改变父类的money字段的值，但字段不具有多态性，所以这里被屏蔽了
            showMeTheMoney();//由于多态性，方法接受者的实际类型为Son
        }
        public void showMeTheMoney() {
            System.out.println("I am Father, i have $" + money);
        }
    }
    static class Son extends Father {
        public int money = 3;
        public Son() {
            money = 4;//改变子类money的值
            showMeTheMoney();
        }
        public void showMeTheMoney() {
            System.out.println("I am Son, i have $" + money);
        }
    }
    public static void main(String[] args) {
        Father guy = new Son();
        //在Son类创建的时候，首先隐式调用了Father的构造函数
        //而Father构造函数中对showMeTheMoney()的调用一次虚方法调用
        //==实际执行的版本是Son::showMeTheMoney()方法，所以输出的是"I am son"==
        //此时父类的money字段被初始化为2了，==但Son::showMeTheMoney()访问的是子类的money字段==
        //这时候自然还是0（类加载的准备阶段，虚拟机默认的赋值），因为它要等到子类的构造函数执行时才会被初始化
        
        System.out.println("This gay has $" + guy.money);//通过静态类型访问到了父类中的money，输出2
    }
}
//输出结果
I am Son, i have $0
I am Son, i have $4
This gay has $2
```


## 即时编译器JIT

Java程序最初都是通过解释器（`Interpreter`）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为**热点代码**（Hot Spot Code），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码**编译成本地机器码**，并以各种手段尽可能地进行代码优化，运行时完成这个任务的后端编译器被称为**即时编译器**（JIT）。

热点检测方法：
- 基于采样的热点探测：JVM周期检查各个线程的调用栈顶，如果某个方法（某些）经常出现在栈顶，即为热点方法。**难以确认一个方法的热度，但可以方便地获取方法调用关系**
- 基于计数器的热点探测：为每个方法（甚至代码块）设置计数器，执行次数超过阈值即为热点方法。**统计结果严谨，但难以获取方法的调用关系**

## 方法内联是啥

方法内联就是**在程序编译时，编译器将程序中出现的 方法调用的表达式 直接用 该方法的方法体进行替换**

在JVM中，每当有一个方法调用，一个新的栈帧就会被加入虚拟机栈顶，分配的本地变量和参数会存储在这个栈帧中，方法返回时弹出栈帧、销毁并恢复现场。
因此，函数调用是存在一定的开销的，当一个方法的方法体不大，而又被频繁调用，这个时间开销的占比较就会很大，因此引入了方法内联。

对于非虚方法，内联是安全的
但是对于虚方法，需要通过**CHA（类型继承关系分析）**来确定**在目前已加载的类中，某个接口是否有多于一种的实现、某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法等信息**，并根据**CHA**的结果，确定是否进行方法内联，以及内联的方式
> 虚方法必须在运行时进行**方法接受者的多态选择**，可能存在多于一个版本的方法接受者，必须依赖上下文进行**动态分派**

1. 方法的接受者只有一个版本：
   - 假设**应用程序的全貌就是当前运行的这个样子**，并进行内联，称为**守护内联**。
2. CHA的结果指明方法的接受者有多个版本：
   - JIT使用**内联缓存**来缩减方法调用的开销，此时仍然发生了方法调用，但效率是比查询虚方发表快的
     - 内联缓存是一个**建立在目标方法正常入口之前的缓存**。工作原理：在未发生方法调用之前，内联缓存状态为空，当第一次调用发生后，缓存**记录下方法接收者的版本信息，并且每次进行方法调用时都比较接收者的版本**。
     - 如果以后**进来的每次方法调用的版本都是一样的**，则直接通过缓存调用
     - 如果**方法接受者不一致**，说明用到了虚方法的多态特性，则退化为超多态内联缓存，开销较高

## 什么是逃逸分析

逃逸分析与类型继承分析一样，不直接优化代码，而是为其他优化措施提供依据

逃逸分析的原理：分析对象会不会被外部访问，即分析对象动态作用域

> 发生逃逸行为的情况有两种：
> 1. **方法逃逸**：当一个对象在方法中定义之后，作为参数传递到其它方法中
> 2. **线程逃逸**：如类变量或实例变量，可能被其它线程访问到

如果能证明一个对象不会逃逸，或逃逸程度较低，则可以为其采取不同程度的优化：

- **栈上分配**（**不逃逸&&方法逃逸**）：如果一个**对象不会逸出到线程之外**，可以将对象==在栈上分配内存，而不是分配于堆==，对象占用的内存空间随栈帧出栈而销毁，从而减轻垃圾回收的压力。
- **同步消除**（**不逃逸&&方法逃逸**）：如果一个**变量不会逸出线程**，则这个变量的读写不会有竞争，可以消除掉对其的**同步措施**
- **标量替换**（**不逃逸**）：无法再分解为更小的数据来表示的数据称为**标量**（例如int、long及reference等），反之称为**聚合量**，（例如对象）。
  - 如果把一个Java对象拆散，根据程序访问情况，**将其用到的成员变量恢复为原始类型来访问**，就称为标量替换。
  如果逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么在程序执行时，就可能**不去创建这个对象，而改为直接创建其若干成员变量**。这么一来，可以将对象的成员变量在栈上分配和读写，还可以进行进一步优化。

## `String abc = new String("abc");`创建了几个对象

2个，一个是全局字符串常量池中的“abc”字符串对象，另一个是堆中的对象abc

